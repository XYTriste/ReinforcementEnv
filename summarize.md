# 总结
## 蒙特卡洛学习
在上周的学习中，我使用蒙特卡洛学习训练了一个基于21点游戏环境的智能体。使用$\epsilon \quad greedy \quad policy$策略获得动作，不断循环得到一条完整的状态序列。并根据状态序列中各个状态的return来更新状态价值以及行为价值，这是对于状态、行为价值的**无偏估计**。最终的训练效果为:
> 玩家胜率约28%，不输的概率约35%，庄家胜率约65%.

然而这个训练效果并不使人满意。事实上按照经验推测，在21点这样**具有高度随机性**的游戏中（高度随机性指的是，相同状态下采取相同动作在不同的状态序列中得到的后续状态也会不同），双方的胜率应该差不多相等。显然我们对于环境的搭建、算法的认识依然存在偏差。
\
随后我尝试进行了一些调整:
1. **尝试调整$\epsilon$的取值**，在探索率与当前最优的行为价值函数中做出取舍。根据我们学过的知识，探索率太高会导致收敛速度太慢，探索率过低则会导致智能体陷入局部最优解，很难去尝试在已有最优解基础上找到一个更优的解。
2. **尝试定义更完整的观测空间**，观测空间（observation space）是指智能体可以感知和获取信息的所有可能状态的集合。它是描述智能体所处环境的一种方式。观测空间可以是离散的或连续的，也可以是有限的或无限的。我最初使用的观测空间仅仅包含了玩家的状态信息，调整后的观测空间包含了玩家的手牌点数、庄家的明牌点数、是否具有可用的A等信息。
3. **调整环境信息**，考虑到环境信息如果不够完整，即**不公平的规则会影响到游戏的公平性，进而影响智能体的训练**。
4. **调整reward**，reward如果设置的不够合理，则智能体容易学习到错误的策略。从而导致性能不佳。

在经历了上述调整后，我发现问题出现在于我**定义的状态信息不够完整**。在我之前的状态定义中，考虑到玩家只能决定自己的手牌点数，并不能决定庄家的手牌点数，所以将庄家的手牌点数视为环境信息而不纳入考虑。我错误的将状态认定为**智能体自身采取行为或初始情况的一种描述**。
但是问题在于，状态实际上是**描述环境的一种方式，通常由环境中的变量或特征表示**，它**可以是完全由环境决定的，也可以是由环境和智能体的行为共同决定**。所以在代码中描述状态时，还应考虑到环境中的信息，在21点游戏的例子中，就是需要将庄家的明牌点数作为状态的一部分。
但是我们也需要避免将不必要的环境信息纳入状态定义，例如在21点游戏中，我的状态价值函数初始定义如下:
```
 V = np.zeros((32, 12))  # 状态价值，第一维是玩家手牌点数，第二维是庄家明牌点数
```
如果包含了太多不必要的信息，则这个矩阵过大求解起来会十分困难。
在经过调整后，现在的训练效果为:
> 玩家胜率约48%，不输率约为51%，庄家胜率约为49%。
## 超参数
超参数（$hyper \quad parameters$）是在人工智能算法中需要手动指定的参数，用于**控制算法的行为和性能**。与模型参数不同，超参数不能从数据中学习，需要通过经验、实验或优化等方法来确定最佳值。常见的超参数包括学习率、正则化系数、批量大小、神经网络层数和节点数、损失函数等。超参数的选择对模型的性能和泛化能力有重要影响，因此超参数的选择需要谨慎。
常见的超参数选择方法是**网格搜索（Grid Search**）和**随机搜索（Random Search）**。除此之外，贝叶斯优化（Bayesian Optimization）和遗传算法（Genetic Algorithm）等也是常用的超参数优化方法。
在我们目前所学过的内容中，我们接触到了以下超参数:

1. $\gamma$，折扣因子，英文名称<span style="font-family: Times New Roman; font-size:20px;">discount factor</span>。它用于平衡即时奖励和未来奖励的重要性，需要根据不同的应用场景和任务来确定。
1.1. **恒定折扣因子**：即折扣因子为一个常数，例如常用的γ=0.99。恒定折扣因子认为未来的奖励与当前的奖励同等重要，没有考虑时间上的权衡。
1.2. **递减折扣因子**：折扣因子会随着时间的推移而减小，即未来的奖励比当前的奖励要少。递减折扣因子可以使得智能体更加关注近期的奖励，而对远期的奖励降低关注。
1.3. **递增折扣因子**：与递减折扣因子相反，折扣因子会随着时间的推移而增加，即未来的奖励比当前的奖励要多。递增折扣因子可以使得智能体更加关注远期的奖励，而对近期的奖励降低关注。
1.4. **超越折扣因子**：一种非线性的折扣因子，可以使得未来的奖励比线性折扣因子更具有权重。例如，超越折扣因子可以定义为γt，其中t是当前时间步数，γ为一个小于1的超参数.

2. <span style="font-size:20px;">$\epsilon $</span>, <span style="font-family: Times New Roman; font-size:20px;">epsilon greedy policy</span>中决定"探索率"的参数。这个参数值的大小影响到算法迭代时对于状态空间的探索。如果$\epsilon$设置的过小，智能体更可能选择**当前被认为是最优的动作**，从而忽视对于其他动作的探索。这可能导致智能体陷入局部最优解，无法找到全局最优解。如果$\epsilon$设置的过大，智能体更可能执行随机动作，导致收敛速度变慢和性能下降。
这里值得一提的是，在<span style="font-family: Times New Roman; font-size:20px;">epsilon greedy policy</span>策略中，只要我们能够保证$\epsilon$随着采样次数无限增多而趋向于0，我们就能够保证智能体策略收敛至贪婪策略。这被称为$GLIE(greedy\ in\ the\ limit\ with\ infinite\ exploration)$性质。


# Sarsa算法
参数 $\gamma = 0.9, \epsilon = 0.3, \alpha = 0.1$
初始的行为价值函数$Q_s^a = 0, s \in S, a \in A$
当**移动、撞墙、到达终点**的奖励分别设置为$(0、-1、1)$时，智能体达到终点所用的时间步为:
![avatar](/GridWind/images/Sarsa_r0.png)
可以看到即便是到达了终点，智能体的行为价值函数收敛的速度依然非常慢。

---
而当我们将奖励重新调整为$(-1，-1, 1)$时，智能体到达终点所用的时间步为:
![avatar](/GridWind/images/Sarsa_r1.png)
我们发现当经历了一定数量的episode后，智能体的收敛速度明显加快了。

---
导致上述问题的原因并不复杂，主要源于Sarsa算法的行为价值函数的特殊性。
Sarsa算法的迭代行为价值函数可以表示为:
$$
Q(s_t, a_t) \gets Q(s_t, a_t) + \alpha[r_{t+1} + \gamma Q(s_{t+1}, a_{t+1}) - Q(s_t, a_t)]
$$
当奖励为0时，在首条episode结束时，除了终点处前一步的行为价值会被更新为非零值，其他点处的行为价值仍然保持为0:
$$
Q(s_t, a_t) \gets Q(s_t, a_t) + \alpha[ {\color{red}{0}} + \gamma Q(s_{t+1}, a_{t+1}) - Q(s_t, a_t)]\quad  \forall t \in [0, T - 1) \\
Q(s_t, a_t) \gets Q(s_t, a_t) + \alpha[ {\color{red}{1}} + \gamma Q(s_{t+1}, a_{t+1}) - Q(s_t, a_t)]\quad Only \ t = T - 1
$$
而当奖励为-1时，无论经历第几条episode。我们每一次的移动都将会把当前行为的行为价值函数更新为非零值:
$$
Q(s_t, a_t) \gets Q(s_t, a_t) + \alpha[ {\color{red}{-1}} + \gamma Q(s_{t+1}, a_{t+1}) - Q(s_t, a_t)]\quad  {\color{red}{\forall t \in [0, T - 1]}}
$$

## 杂谈
### 关于TD target、TD error
在介绍这些概念之前，我们需要提醒自己。TD学习是**无模型的学习方法**，也就是说在TD学习时，不需要对环境建立显式的模型，而是**通过不断地观察环境的反馈，学习出策略的价值函数**。具体地，TD学习算法通过在不同状态之间进行转移，计算出状态价值函数的估计值，并不断地更新这些估计值，以使其逐渐趋近于真实的状态价值函数。因此，TD学习是一种基于经验的学习方法，不需要事先了解环境的具体规律和概率。
在马尔科夫决策过程中，状态价值函数的定义为:
$$
\begin{align}
v_\pi(s) &= \Bbb E[G_t\mid S_t=s] \\
&= \Bbb E[R_{t+1} + \gamma v_{\pi}(S_{t+1})\mid S_t = s] \\
\end{align}\\
$$
显然我们注意到，状态价值函数是**基于策略**的，也就是说**不同的策略下，同一个状态可能具有不同的状态价值**。

现在我们再来看看TD target，它的定义为:
$$
target = R_{t+1} + \gamma v(S_{t+1})
$$
TD error的定义为:
$$
target - v(S_t) = R_{t+1} + \gamma v(S_{t+1}) - v(S_t)
$$
其中，$v(S_t)$是我们当前的状态价值，而$v(S_{t+1})$是我们在当前状态下，通过某种策略获得一个行为，采取行为后达到的后续状态$S_{t+1}$。注意，$v(S_{t+1})$是我们通过当前策略得到的，这意味着我们假设在当前状态下，智能体会采取当前策略所建议的行动，并在接下来的状态中按照该策略继续行动。这种假设的前提是当前策略在未来的时间步中仍然是最优的，因此这种预测是基于当前策略和当前状态下可选行动的评估。
举个例子:
> 假设你是一名学生，每天上学需要乘坐公交车。你可以选择搭乘每天都会准时到达的公交车A，或者搭乘经常会晚点的公交车B。现在你想使用强化学习来制定选择公交车的策略。
在这个例子中，状态可以是当前时间、当前位置、上一次乘坐公交车的时间等等信息。行为是选择搭乘公交车A或B。奖励可以是到达学校的时间，如果你迟到了，那么奖励会变得负数。
在此基础上，假设你选择了当前策略，比如每天都选择搭乘公交车B。当你在某一天搭乘公交车B到学校时，你会通过TD学习来更新当前未乘车状态的状态价值函数。在这种情况下，TD目标值就是使用当前策略来预测下一个状态的状态价值，即使用到达学校的时间（即时奖励）和是否会挨批评（后续状态价值）来修正当前还未采取行为时的状态价值。由于使用了当前策略，因此这个估计是有偏的。因为我们并没有坐过公交车A，也就不能准确的估计出我们当前的状态的价值。

因此，$v(S_t)$只是我们在迭代过程中对真实的$v_\pi(S_t)$的估计。